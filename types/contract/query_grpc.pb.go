// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: contract/query.proto

package contract

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ContractQuery_UserInteractionContracts_FullMethodName = "/contract.ContractQuery/UserInteractionContracts"
	ContractQuery_ContractKeys_FullMethodName             = "/contract.ContractQuery/ContractKeys"
	ContractQuery_ContractEntry_FullMethodName            = "/contract.ContractQuery/ContractEntry"
	ContractQuery_ContractData_FullMethodName             = "/contract.ContractQuery/ContractData"
	ContractQuery_ContractCode_FullMethodName             = "/contract.ContractQuery/ContractCode"
	ContractQuery_ContractCodes_FullMethodName            = "/contract.ContractQuery/ContractCodes"
	ContractQuery_ContractsAtLedger_FullMethodName        = "/contract.ContractQuery/ContractsAtLedger"
	ContractQuery_ContractInvoke_FullMethodName           = "/contract.ContractQuery/ContractInvoke"
	ContractQuery_ContractInvokes_FullMethodName          = "/contract.ContractQuery/ContractInvokes"
	ContractQuery_ContractInvokesAtLedger_FullMethodName  = "/contract.ContractQuery/ContractInvokesAtLedger"
	ContractQuery_ContractInvokesByUser_FullMethodName    = "/contract.ContractQuery/ContractInvokesByUser"
	ContractQuery_ContractKeyXdr_FullMethodName           = "/contract.ContractQuery/ContractKeyXdr"
)

// ContractQueryClient is the client API for ContractQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractQueryClient interface {
	// UserInteractionContracts queries list contracts user has interacted.
	UserInteractionContracts(ctx context.Context, in *UserInteractionContractsRequest, opts ...grpc.CallOption) (*UserInteractionContractsResponse, error)
	// ContractKeys queries list newest keys of contract
	ContractKeys(ctx context.Context, in *ContractKeysRequest, opts ...grpc.CallOption) (*ContractKeysResponse, error)
	// ContractEntry queries contract entry with the given key
	ContractEntry(ctx context.Context, in *ContractEntryRequest, opts ...grpc.CallOption) (*ContractEntryResponse, error)
	// ContractData queries list newest data entries of contract
	ContractData(ctx context.Context, in *ContractDataRequest, opts ...grpc.CallOption) (*ContractDataResponse, error)
	// ContracCode queries contract code data with the given contract id
	ContractCode(ctx context.Context, in *ContractCodeRequest, opts ...grpc.CallOption) (*ContractCodeResponse, error)
	// ContracCodes queries contract codes have been deployed
	ContractCodes(ctx context.Context, in *ContractCodesRequest, opts ...grpc.CallOption) (*ContractCodesResponse, error)
	// ContractsAtLedger queries contract codes have been deployed at the given
	// ledger
	ContractsAtLedger(ctx context.Context, in *ContractsAtLedgerRequest, opts ...grpc.CallOption) (*ContractsAtLedgerResponse, error)
	// ContractInvoke queries contract data have been invoked at the
	// given transaction hash
	ContractInvoke(ctx context.Context, in *ContractInvokeRequest, opts ...grpc.CallOption) (*ContractInvokeResponse, error)
	// ContractInvokes queries contract data have been invoked by the
	// given contract id
	ContractInvokes(ctx context.Context, in *ContractInvokesRequest, opts ...grpc.CallOption) (*ContractInvokesResponse, error)
	// ContractInvokesAtLedger queries contract data have been invoked at the
	// given ledger
	ContractInvokesAtLedger(ctx context.Context, in *ContractInvokesAtLedgerRequest, opts ...grpc.CallOption) (*ContractInvokesAtLedgerResponse, error)
	// ContractInvokesByUser queries contract data have been invoked by the
	// given address
	ContractInvokesByUser(ctx context.Context, in *ContractInvokesByUserRequest, opts ...grpc.CallOption) (*ContractInvokesByUserResponse, error)
	// ContractKeyXdr queries key xdr
	// given keyName and keyType
	ContractKeyXdr(ctx context.Context, in *ContractKeyXdrRequest, opts ...grpc.CallOption) (*ContractKeyXdrResponse, error)
}

type contractQueryClient struct {
	cc grpc.ClientConnInterface
}

func NewContractQueryClient(cc grpc.ClientConnInterface) ContractQueryClient {
	return &contractQueryClient{cc}
}

func (c *contractQueryClient) UserInteractionContracts(ctx context.Context, in *UserInteractionContractsRequest, opts ...grpc.CallOption) (*UserInteractionContractsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInteractionContractsResponse)
	err := c.cc.Invoke(ctx, ContractQuery_UserInteractionContracts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractKeys(ctx context.Context, in *ContractKeysRequest, opts ...grpc.CallOption) (*ContractKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractKeysResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractEntry(ctx context.Context, in *ContractEntryRequest, opts ...grpc.CallOption) (*ContractEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractEntryResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractData(ctx context.Context, in *ContractDataRequest, opts ...grpc.CallOption) (*ContractDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractDataResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractCode(ctx context.Context, in *ContractCodeRequest, opts ...grpc.CallOption) (*ContractCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractCodeResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractCodes(ctx context.Context, in *ContractCodesRequest, opts ...grpc.CallOption) (*ContractCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractCodesResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractsAtLedger(ctx context.Context, in *ContractsAtLedgerRequest, opts ...grpc.CallOption) (*ContractsAtLedgerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractsAtLedgerResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractsAtLedger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractInvoke(ctx context.Context, in *ContractInvokeRequest, opts ...grpc.CallOption) (*ContractInvokeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractInvokeResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractInvoke_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractInvokes(ctx context.Context, in *ContractInvokesRequest, opts ...grpc.CallOption) (*ContractInvokesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractInvokesResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractInvokes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractInvokesAtLedger(ctx context.Context, in *ContractInvokesAtLedgerRequest, opts ...grpc.CallOption) (*ContractInvokesAtLedgerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractInvokesAtLedgerResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractInvokesAtLedger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractInvokesByUser(ctx context.Context, in *ContractInvokesByUserRequest, opts ...grpc.CallOption) (*ContractInvokesByUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractInvokesByUserResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractInvokesByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractQueryClient) ContractKeyXdr(ctx context.Context, in *ContractKeyXdrRequest, opts ...grpc.CallOption) (*ContractKeyXdrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContractKeyXdrResponse)
	err := c.cc.Invoke(ctx, ContractQuery_ContractKeyXdr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContractQueryServer is the server API for ContractQuery service.
// All implementations must embed UnimplementedContractQueryServer
// for forward compatibility.
type ContractQueryServer interface {
	// UserInteractionContracts queries list contracts user has interacted.
	UserInteractionContracts(context.Context, *UserInteractionContractsRequest) (*UserInteractionContractsResponse, error)
	// ContractKeys queries list newest keys of contract
	ContractKeys(context.Context, *ContractKeysRequest) (*ContractKeysResponse, error)
	// ContractEntry queries contract entry with the given key
	ContractEntry(context.Context, *ContractEntryRequest) (*ContractEntryResponse, error)
	// ContractData queries list newest data entries of contract
	ContractData(context.Context, *ContractDataRequest) (*ContractDataResponse, error)
	// ContracCode queries contract code data with the given contract id
	ContractCode(context.Context, *ContractCodeRequest) (*ContractCodeResponse, error)
	// ContracCodes queries contract codes have been deployed
	ContractCodes(context.Context, *ContractCodesRequest) (*ContractCodesResponse, error)
	// ContractsAtLedger queries contract codes have been deployed at the given
	// ledger
	ContractsAtLedger(context.Context, *ContractsAtLedgerRequest) (*ContractsAtLedgerResponse, error)
	// ContractInvoke queries contract data have been invoked at the
	// given transaction hash
	ContractInvoke(context.Context, *ContractInvokeRequest) (*ContractInvokeResponse, error)
	// ContractInvokes queries contract data have been invoked by the
	// given contract id
	ContractInvokes(context.Context, *ContractInvokesRequest) (*ContractInvokesResponse, error)
	// ContractInvokesAtLedger queries contract data have been invoked at the
	// given ledger
	ContractInvokesAtLedger(context.Context, *ContractInvokesAtLedgerRequest) (*ContractInvokesAtLedgerResponse, error)
	// ContractInvokesByUser queries contract data have been invoked by the
	// given address
	ContractInvokesByUser(context.Context, *ContractInvokesByUserRequest) (*ContractInvokesByUserResponse, error)
	// ContractKeyXdr queries key xdr
	// given keyName and keyType
	ContractKeyXdr(context.Context, *ContractKeyXdrRequest) (*ContractKeyXdrResponse, error)
	mustEmbedUnimplementedContractQueryServer()
}

// UnimplementedContractQueryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedContractQueryServer struct{}

func (UnimplementedContractQueryServer) UserInteractionContracts(context.Context, *UserInteractionContractsRequest) (*UserInteractionContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInteractionContracts not implemented")
}
func (UnimplementedContractQueryServer) ContractKeys(context.Context, *ContractKeysRequest) (*ContractKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractKeys not implemented")
}
func (UnimplementedContractQueryServer) ContractEntry(context.Context, *ContractEntryRequest) (*ContractEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractEntry not implemented")
}
func (UnimplementedContractQueryServer) ContractData(context.Context, *ContractDataRequest) (*ContractDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractData not implemented")
}
func (UnimplementedContractQueryServer) ContractCode(context.Context, *ContractCodeRequest) (*ContractCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractCode not implemented")
}
func (UnimplementedContractQueryServer) ContractCodes(context.Context, *ContractCodesRequest) (*ContractCodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractCodes not implemented")
}
func (UnimplementedContractQueryServer) ContractsAtLedger(context.Context, *ContractsAtLedgerRequest) (*ContractsAtLedgerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractsAtLedger not implemented")
}
func (UnimplementedContractQueryServer) ContractInvoke(context.Context, *ContractInvokeRequest) (*ContractInvokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractInvoke not implemented")
}
func (UnimplementedContractQueryServer) ContractInvokes(context.Context, *ContractInvokesRequest) (*ContractInvokesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractInvokes not implemented")
}
func (UnimplementedContractQueryServer) ContractInvokesAtLedger(context.Context, *ContractInvokesAtLedgerRequest) (*ContractInvokesAtLedgerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractInvokesAtLedger not implemented")
}
func (UnimplementedContractQueryServer) ContractInvokesByUser(context.Context, *ContractInvokesByUserRequest) (*ContractInvokesByUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractInvokesByUser not implemented")
}
func (UnimplementedContractQueryServer) ContractKeyXdr(context.Context, *ContractKeyXdrRequest) (*ContractKeyXdrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContractKeyXdr not implemented")
}
func (UnimplementedContractQueryServer) mustEmbedUnimplementedContractQueryServer() {}
func (UnimplementedContractQueryServer) testEmbeddedByValue()                       {}

// UnsafeContractQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractQueryServer will
// result in compilation errors.
type UnsafeContractQueryServer interface {
	mustEmbedUnimplementedContractQueryServer()
}

func RegisterContractQueryServer(s grpc.ServiceRegistrar, srv ContractQueryServer) {
	// If the following call pancis, it indicates UnimplementedContractQueryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ContractQuery_ServiceDesc, srv)
}

func _ContractQuery_UserInteractionContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInteractionContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).UserInteractionContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_UserInteractionContracts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).UserInteractionContracts(ctx, req.(*UserInteractionContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractKeys(ctx, req.(*ContractKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractEntry(ctx, req.(*ContractEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractData(ctx, req.(*ContractDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractCode(ctx, req.(*ContractCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractCodes(ctx, req.(*ContractCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractsAtLedger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractsAtLedgerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractsAtLedger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractsAtLedger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractsAtLedger(ctx, req.(*ContractsAtLedgerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractInvoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractInvokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractInvoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractInvoke_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractInvoke(ctx, req.(*ContractInvokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractInvokes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractInvokesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractInvokes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractInvokes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractInvokes(ctx, req.(*ContractInvokesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractInvokesAtLedger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractInvokesAtLedgerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractInvokesAtLedger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractInvokesAtLedger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractInvokesAtLedger(ctx, req.(*ContractInvokesAtLedgerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractInvokesByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractInvokesByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractInvokesByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractInvokesByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractInvokesByUser(ctx, req.(*ContractInvokesByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContractQuery_ContractKeyXdr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractKeyXdrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractQueryServer).ContractKeyXdr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContractQuery_ContractKeyXdr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractQueryServer).ContractKeyXdr(ctx, req.(*ContractKeyXdrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContractQuery_ServiceDesc is the grpc.ServiceDesc for ContractQuery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContractQuery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contract.ContractQuery",
	HandlerType: (*ContractQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserInteractionContracts",
			Handler:    _ContractQuery_UserInteractionContracts_Handler,
		},
		{
			MethodName: "ContractKeys",
			Handler:    _ContractQuery_ContractKeys_Handler,
		},
		{
			MethodName: "ContractEntry",
			Handler:    _ContractQuery_ContractEntry_Handler,
		},
		{
			MethodName: "ContractData",
			Handler:    _ContractQuery_ContractData_Handler,
		},
		{
			MethodName: "ContractCode",
			Handler:    _ContractQuery_ContractCode_Handler,
		},
		{
			MethodName: "ContractCodes",
			Handler:    _ContractQuery_ContractCodes_Handler,
		},
		{
			MethodName: "ContractsAtLedger",
			Handler:    _ContractQuery_ContractsAtLedger_Handler,
		},
		{
			MethodName: "ContractInvoke",
			Handler:    _ContractQuery_ContractInvoke_Handler,
		},
		{
			MethodName: "ContractInvokes",
			Handler:    _ContractQuery_ContractInvokes_Handler,
		},
		{
			MethodName: "ContractInvokesAtLedger",
			Handler:    _ContractQuery_ContractInvokesAtLedger_Handler,
		},
		{
			MethodName: "ContractInvokesByUser",
			Handler:    _ContractQuery_ContractInvokesByUser_Handler,
		},
		{
			MethodName: "ContractKeyXdr",
			Handler:    _ContractQuery_ContractKeyXdr_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contract/query.proto",
}
